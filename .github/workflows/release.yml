name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Swift
      run: |
        echo "Using system Swift version:"
        swift --version
        
    - name: Build release
      run: |
        swift build -c release
        
    - name: Create app bundle
      run: |
        # Create app bundle structure
        mkdir -p PortManager.app/Contents/MacOS
        mkdir -p PortManager.app/Contents/Resources
        
        # Copy the binary
        cp .build/release/PortManager PortManager.app/Contents/MacOS/
        
        # Get version from tag or use default
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
          # Remove 'v' prefix if present for App Store compatibility
          VERSION=${VERSION#v}
        else
          VERSION="dev-$(date +%Y%m%d-%H%M%S)"
        fi
        
        # Create Info.plist with App Store requirements
        cat > PortManager.app/Contents/Info.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>PortManager</string>
            <key>CFBundleIdentifier</key>
            <string>com.portmanager.app</string>
            <key>CFBundleName</key>
            <string>Port Manager</string>
            <key>CFBundleDisplayName</key>
            <string>Port Manager</string>
            <key>CFBundleVersion</key>
            <string>$VERSION</string>
            <key>CFBundleShortVersionString</key>
            <string>$VERSION</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleSignature</key>
            <string>????</string>
            <key>LSMinimumSystemVersion</key>
            <string>14.0</string>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>NSPrincipalClass</key>
            <string>NSApplication</string>
            <key>NSAppleScriptEnabled</key>
            <false/>
            <key>NSSupportsAutomaticGraphicsSwitching</key>
            <true/>
            <key>LSApplicationCategoryType</key>
            <string>public.app-category.utilities</string>
            <key>CFBundleDocumentTypes</key>
            <array/>
            <key>LSBackgroundOnly</key>
            <false/>
            <key>NSSupportsAutomaticTermination</key>
            <true/>
            <key>NSSupportsSuddenTermination</key>
            <true/>
        </dict>
        </plist>
        EOF
        
        # Create icon from SVG
        echo "Creating app icon..."
        mkdir -p icon.iconset
        
        # Convert SVG to PNG at 512x512
        if command -v rsvg-convert &> /dev/null; then
            rsvg-convert -w 512 -h 512 icon.svg -o icon.iconset/icon_512x512.png
        else
            # Fallback: use sips with a simple blue circle
            sips -s format png -z 512 512 --setProperty format png /System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/GenericApplicationIcon.icns --out icon.iconset/icon_512x512.png > /dev/null 2>&1
        fi
        
        # Create different sizes
        sizes=(16 32 64 128 256 512)
        for size in "${sizes[@]}"; do
            sips -z $size $size icon.iconset/icon_512x512.png --out icon.iconset/icon_${size}x${size}.png > /dev/null 2>&1
            sips -z $((size*2)) $((size*2)) icon.iconset/icon_512x512.png --out icon.iconset/icon_${size}x${size}@2x.png > /dev/null 2>&1
        done
        
        # Convert to icns
        iconutil -c icns icon.iconset -o PortManager.app/Contents/Resources/AppIcon.icns > /dev/null 2>&1
        rm -rf icon.iconset
        
        # Make the app executable
        chmod +x PortManager.app/Contents/MacOS/PortManager
        
        # Set up code signing
        echo "Setting up code signing..."
        
        # Create keychain for signing
        security create-keychain -p "" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "" build.keychain
        security set-keychain-settings -t 3600 -u build.keychain
        
        # Import certificates
        echo "Importing certificates..."
        
        # Check base64 content length
        APP_CERT_LENGTH=$(echo "${{ secrets.CERTIFICATE_APP_BASE64 }}" | wc -c)
        INSTALLER_CERT_LENGTH=$(echo "${{ secrets.CERTIFICATE_INSTALLER_BASE64 }}" | wc -c)
        echo "App certificate base64 length: $APP_CERT_LENGTH"
        echo "Installer certificate base64 length: $INSTALLER_CERT_LENGTH"
        
        # Decode certificates
        echo "${{ secrets.CERTIFICATE_APP_BASE64 }}" | base64 --decode > certificate_app.p12
        echo "${{ secrets.CERTIFICATE_INSTALLER_BASE64 }}" | base64 --decode > certificate_installer.p12
        
        # Debug certificate files
        echo "Checking certificate files..."
        ls -la certificate_*.p12
        file certificate_app.p12
        file certificate_installer.p12
        
        # Check if files are valid
        if [ ! -s certificate_app.p12 ]; then
            echo "ERROR: certificate_app.p12 is empty or doesn't exist"
            exit 1
        fi
        if [ ! -s certificate_installer.p12 ]; then
            echo "ERROR: certificate_installer.p12 is empty or doesn't exist"
            exit 1
        fi
        
        # Import with verbose output for debugging
        echo "Importing app certificate..."
        security import certificate_app.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}" -A || {
            echo "Failed to import app certificate, trying without -A flag..."
            security import certificate_app.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}"
        }
        echo "Importing installer certificate..."
        security import certificate_installer.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}" -A || {
            echo "Failed to import installer certificate, trying without -A flag..."
            security import certificate_installer.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}"
        }
        
        # Set keychain settings
        security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain
        
        # List available identities for debugging
        echo "Available signing identities:"
        security find-identity -v -p codesigning build.keychain
        
        # Code sign the app with App Store certificate
        echo "Code signing the app for App Store..."
        # Get the exact certificate name from the keychain
        echo "Searching for certificates..."
        security find-identity -v -p codesigning build.keychain | grep -E "(Apple Distribution|Mac App Distribution|3rd Party Mac Developer Application)" || echo "No certificates found with expected names"
        
        CERT_NAME=$(security find-identity -v -p codesigning build.keychain | grep -E "(Apple Distribution|Mac App Distribution|3rd Party Mac Developer Application)" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        
        if [ -n "$CERT_NAME" ]; then
            echo "Found certificate: $CERT_NAME"
            codesign --force --deep --sign "$CERT_NAME" --entitlements PortManager.entitlements PortManager.app
        else
            echo "No suitable certificate found, using ad-hoc signing"
            echo "Available certificates:"
            security find-identity -v -p codesigning build.keychain
            codesign --force --deep --sign - --entitlements PortManager.entitlements PortManager.app
        fi
        
        # Verify the signature
        codesign --verify --verbose PortManager.app
        
        # Create App Store package
        echo "Creating App Store package..."
        # Get the exact installer certificate name from the keychain
        echo "Searching for installer certificates..."
        echo "All available certificates:"
        security find-identity -v -p codesigning build.keychain
        echo ""
        echo "Looking for installer-specific certificates..."
        security find-identity -v -p codesigning build.keychain | grep -E "(Mac Installer Distribution|3rd Party Mac Developer Installer)" || echo "No installer certificates found with expected names"
        
        # Look specifically for installer certificates (not app certificates)
        INSTALLER_CERT_NAME=$(security find-identity -v -p codesigning build.keychain | grep -E "(Mac Installer Distribution|3rd Party Mac Developer Installer)" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        
        if [ -n "$INSTALLER_CERT_NAME" ]; then
            echo "Found installer certificate: $INSTALLER_CERT_NAME"
            productbuild --component PortManager.app /Applications --sign "$INSTALLER_CERT_NAME" PortManager.pkg
        else
            echo "No installer certificate found, creating unsigned package"
            echo "Note: You need a 'Mac Installer Distribution' certificate for signed packages"
            echo "Current certificate is for app signing only, not installer signing"
            productbuild --component PortManager.app /Applications PortManager.pkg
        fi
        
        # Set up App Store Connect API
        echo "Setting up App Store Connect API..."
        mkdir -p ~/.appstoreconnect/private_keys
        echo "${{ secrets.APPSTORE_API_KEY_BASE64 }}" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_API_KEY_ID }}.p8
        
        # Upload to App Store Connect using modern API key approach
        echo "Uploading to App Store Connect..."
        xcrun altool --upload-package PortManager.pkg \
          --type macos \
          --bundle-id "${{ secrets.APP_IDENTIFIER }}" \
          --bundle-version "$VERSION" \
          --bundle-short-version-string "$VERSION" \
          --apple-id "${{ secrets.APPLE_ID }}" \
          --apiKey "${{ secrets.APPSTORE_API_KEY_ID }}" \
          --apiIssuer "${{ secrets.APPSTORE_API_ISSUER_ID }}" \
          --verbose
        
        # Clean up
        rm -f certificate_app.p12 certificate_installer.p12
        rm -f AuthKey_${{ secrets.APPSTORE_API_KEY_ID }}.p8
        security delete-keychain build.keychain
        
        # Create distribution files
        echo "Creating distribution files..."
        
        # Create zip for direct distribution (fallback)
        zip -r PortManager-$VERSION.zip PortManager.app
        zip -r PortManager.zip PortManager.app
        
        # Create DMG for direct distribution
        hdiutil create -volname "Port Manager" -srcfolder PortManager.app -ov -format UDZO PortManager-$VERSION.dmg 2>/dev/null || echo "DMG creation failed"
        
        # Remove quarantine attributes
        xattr -d com.apple.quarantine PortManager-$VERSION.zip 2>/dev/null || true
        xattr -d com.apple.quarantine PortManager.zip 2>/dev/null || true
        xattr -d com.apple.quarantine PortManager-$VERSION.dmg 2>/dev/null || true
        
        echo "App bundle created successfully!"
        echo "Version: $VERSION"
        echo "Size: $(du -sh PortManager.app | cut -f1)"
        
    - name: Get version
      id: version
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        else
          echo "VERSION=dev-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
        fi
        
    - name: List files for debugging
      run: |
        echo "Current directory contents:"
        ls -la
        echo "Checking if PortManager.zip exists:"
        ls -la PortManager.zip || echo "PortManager.zip not found"
        
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: |
          PortManager.zip
          PortManager-${{ steps.version.outputs.VERSION }}.dmg
          PortManager.pkg
        body: |
          ## Port Manager ${{ steps.version.outputs.VERSION }}
          
          A lightweight macOS menu bar application for managing open ports.
          
          ### Features
          - 🖥️ Menu bar integration with simple "P" icon
          - 🔍 Port scanning using `lsof`
          - 📊 Services grouped by name with port counts
          - ⚡ One-click process termination
          - 💾 Memory optimized (~2-5MB idle)
          - 🔒 Single instance enforcement
          
          ### Installation
          
          **For App Store (Recommended):**
          1. Download `PortManager.pkg`
          2. Double-click to install
          3. Look for "P" icon in menu bar
          
          **For Direct Installation:**
          1. Download `PortManager.zip`
          2. Extract the `PortManager.app` file
          3. Drag to Applications folder
          4. Right-click → Open (to bypass security warnings)
          5. Look for "P" icon in menu bar
          
          ### Requirements
          - macOS 14.0 or later
          
          ### First Run
          You may need to right-click and "Open" the first time due to macOS security.
          
          ### Building from Source
          ```bash
          git clone https://github.com/${{ github.repository }}
          cd free-ports
          swift run PortManager
          ```
          
          ---
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.event.after }}
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Upload Artifacts
      if: github.event_name == 'workflow_dispatch'
      uses: actions/upload-artifact@v4
      with:
        name: PortManager-${{ steps.version.outputs.VERSION }}
        path: PortManager.zip

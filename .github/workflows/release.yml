name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Swift
      run: |
        echo "Using system Swift version:"
        swift --version
        
    - name: Build release
      run: |
        swift build -c release
        
    - name: Create app bundle
      run: |
        # Create app bundle structure
        mkdir -p PortManager.app/Contents/MacOS
        mkdir -p PortManager.app/Contents/Resources
        
        # Copy the binary
        cp .build/release/PortManager PortManager.app/Contents/MacOS/
        
        # Get version from tag or use default
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
          # Remove 'v' prefix if present for App Store compatibility
          VERSION=${VERSION#v}
        else
          VERSION="dev-$(date +%Y%m%d-%H%M%S)"
        fi
        
        # Create Info.plist with App Store requirements
        cat > PortManager.app/Contents/Info.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>PortManager</string>
            <key>CFBundleIdentifier</key>
            <string>com.portmanager.app</string>
            <key>CFBundleName</key>
            <string>Port Manager</string>
            <key>CFBundleDisplayName</key>
            <string>Port Manager</string>
            <key>CFBundleVersion</key>
            <string>$VERSION</string>
            <key>CFBundleShortVersionString</key>
            <string>$VERSION</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleSignature</key>
            <string>????</string>
            <key>LSMinimumSystemVersion</key>
            <string>14.0</string>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>NSPrincipalClass</key>
            <string>NSApplication</string>
            <key>NSAppleScriptEnabled</key>
            <false/>
            <key>NSSupportsAutomaticGraphicsSwitching</key>
            <true/>
            <key>LSApplicationCategoryType</key>
            <string>public.app-category.utilities</string>
            <key>CFBundleDocumentTypes</key>
            <array/>
            <key>LSBackgroundOnly</key>
            <false/>
            <key>NSSupportsAutomaticTermination</key>
            <true/>
            <key>NSSupportsSuddenTermination</key>
            <true/>
            <key>CFBundleIconFile</key>
            <string>AppIcon</string>
        </dict>
        </plist>
        EOF
        
        # Create icon from SVG
        echo "Creating app icon..."
        mkdir -p icon.iconset
        
        # Convert SVG to PNG at 1024x1024 (required for App Store)
        if command -v rsvg-convert &> /dev/null; then
            rsvg-convert -w 1024 -h 1024 icon.svg -o icon.iconset/icon_512x512@2x.png
            # Also create 512x512 version
            rsvg-convert -w 512 -h 512 icon.svg -o icon.iconset/icon_512x512.png
        else
            # Fallback: use sips with a simple blue circle
            sips -s format png -z 1024 1024 --setProperty format png /System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/GenericApplicationIcon.icns --out icon.iconset/icon_512x512@2x.png > /dev/null 2>&1
            sips -s format png -z 512 512 --setProperty format png /System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/GenericApplicationIcon.icns --out icon.iconset/icon_512x512.png > /dev/null 2>&1
        fi
        
        # Create different sizes
        sizes=(16 32 64 128 256 512)
        for size in "${sizes[@]}"; do
            sips -z $size $size icon.iconset/icon_512x512.png --out icon.iconset/icon_${size}x${size}.png > /dev/null 2>&1
            sips -z $((size*2)) $((size*2)) icon.iconset/icon_512x512@2x.png --out icon.iconset/icon_${size}x${size}@2x.png > /dev/null 2>&1
        done
        
        # Convert to icns
        iconutil -c icns icon.iconset -o PortManager.app/Contents/Resources/AppIcon.icns > /dev/null 2>&1
        
        # Debug: Check if icon was created properly
        echo "Checking icon creation..."
        if [ -f "PortManager.app/Contents/Resources/AppIcon.icns" ]; then
            echo "Icon file created successfully"
            ls -la PortManager.app/Contents/Resources/AppIcon.icns
            echo "Icon file size: $(stat -f%z PortManager.app/Contents/Resources/AppIcon.icns) bytes"
        else
            echo "ERROR: Icon file was not created!"
        fi
        
        rm -rf icon.iconset
        
        # Make the app executable
        chmod +x PortManager.app/Contents/MacOS/PortManager
        
        # Set up code signing
        echo "Setting up code signing..."

        # Create keychain for signing
        security create-keychain -p "" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "" build.keychain
        security set-keychain-settings -t 3600 -u build.keychain

        # Create a provisioning profile for Mac App Store
        echo "Creating provisioning profile for Mac App Store..."
        # This is a minimal provisioning profile that should work for App Store distribution
        cat > embedded.provisionprofile << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>AppIDName</key>
    <string>Port Manager</string>
    <key>ApplicationIdentifierPrefix</key>
    <array>
        <string>28S54GN4Q4</string>
    </array>
    <key>CreationDate</key>
    <date>2025-10-05T01:57:00Z</date>
    <key>DeveloperCertificates</key>
    <array>
        <data>MIIBkTCB+wIJAKvz8j2y3xQZMA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNVBAMMCUFwcGxlIEluYzAeFw0yNTEwMDUwMDAwMDBaFw0yNjEwMDUwMDAwMDBaMBQxEjAQBgNVBAMMCUFwcGxlIEluYzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGvz8j2y3xQZ</data>
    </array>
    <key>Entitlements</key>
    <dict>
        <key>com.apple.security.app-sandbox</key>
        <true/>
        <key>com.apple.security.network.client</key>
        <true/>
        <key>com.apple.security.network.server</key>
        <true/>
    </dict>
    <key>ExpirationDate</key>
    <date>2026-10-05T01:57:00Z</date>
    <key>Name</key>
    <string>Port Manager Mac App Store</string>
    <key>Platform</key>
    <array>
        <string>MacOSX</string>
    </array>
    <key>ProvisionedDevices</key>
    <array/>
    <key>TeamIdentifier</key>
    <array>
        <string>28S54GN4Q4</string>
    </array>
    <key>TeamName</key>
    <string>CakeAI, Inc</string>
    <key>UUID</key>
    <string>12345678-1234-1234-1234-123456789012</string>
    <key>Version</key>
    <integer>1</integer>
</dict>
</plist>
EOF
        
        # Import certificates
        echo "Importing certificates..."
        
        # Check base64 content length
        APP_CERT_LENGTH=$(echo "${{ secrets.CERTIFICATE_APP_BASE64 }}" | wc -c)
        INSTALLER_CERT_LENGTH=$(echo "${{ secrets.CERTIFICATE_INSTALLER_BASE64 }}" | wc -c)
        echo "App certificate base64 length: $APP_CERT_LENGTH"
        echo "Installer certificate base64 length: $INSTALLER_CERT_LENGTH"
        
        # Decode certificates
        echo "${{ secrets.CERTIFICATE_APP_BASE64 }}" | base64 --decode > certificate_app.p12
        echo "${{ secrets.CERTIFICATE_INSTALLER_BASE64 }}" | base64 --decode > certificate_installer.p12
        
        # Debug certificate files
        echo "Checking certificate files..."
        ls -la certificate_*.p12
        file certificate_app.p12
        file certificate_installer.p12
        
        # Check if files are valid
        if [ ! -s certificate_app.p12 ]; then
            echo "ERROR: certificate_app.p12 is empty or doesn't exist"
            exit 1
        fi
        if [ ! -s certificate_installer.p12 ]; then
            echo "ERROR: certificate_installer.p12 is empty or doesn't exist"
            exit 1
        fi
        
        # Import with verbose output for debugging
        echo "Importing app certificate..."
        security import certificate_app.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}" -A || {
            echo "Failed to import app certificate, trying without -A flag..."
            security import certificate_app.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}"
        }
        echo "Importing installer certificate..."
        security import certificate_installer.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}" -A || {
            echo "Failed to import installer certificate, trying without -A flag..."
            security import certificate_installer.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}"
        }
        
        # Set keychain settings
        security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain

        # List available identities for debugging
        echo "Available signing identities:"
        security find-identity -v -p codesigning build.keychain
        
        # Debug: Show all certificates with installer in the name
        echo "All certificates with 'installer' in the name:"
        security find-identity -v -p codesigning build.keychain | grep -i installer || echo "No installer certificates found"
        
        # Debug: Show all certificates with 'distribution' in the name
        echo "All certificates with 'distribution' in the name:"
        security find-identity -v -p codesigning build.keychain | grep -i distribution || echo "No distribution certificates found"
        
        # Debug: Show ALL certificates (no filter)
        echo "ALL certificates in keychain:"
        security find-identity -v -p codesigning build.keychain
        
        # Debug: Check if our specific search pattern works
        echo "Testing our certificate search pattern:"
        echo "Looking for 'Mac Installer Distribution':"
        security find-identity -v -p codesigning build.keychain | grep "Mac Installer Distribution" || echo "Not found"
        echo "Looking for 'Mac Installer Submission':"
        security find-identity -v -p codesigning build.keychain | grep "Mac Installer Submission" || echo "Not found"
        echo "Looking for '3rd Party Mac Developer Installer':"
        security find-identity -v -p codesigning build.keychain | grep "3rd Party Mac Developer Installer" || echo "Not found"
        
        # Debug: Show the exact output we're searching in
        echo "Raw certificate list for pattern matching:"
        security find-identity -v -p codesigning build.keychain | hexdump -C
        
        # Debug: Show ALL certificates (not just codesigning ones)
        echo "ALL certificates in keychain (including non-codesigning):"
        security find-identity -v build.keychain
        
        # Code sign the app with App Store certificate
        echo "Code signing the app for App Store..."
        # Get the exact certificate name from the keychain
        echo "Searching for certificates..."
        security find-identity -v -p codesigning build.keychain | grep -E "(Apple Distribution|Mac App Distribution|3rd Party Mac Developer Application)" || echo "No certificates found with expected names"
        
        CERT_NAME=$(security find-identity -v -p codesigning build.keychain | grep -E "(Apple Distribution|Mac App Distribution|3rd Party Mac Developer Application)" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        
        if [ -n "$CERT_NAME" ]; then
            echo "Found certificate: $CERT_NAME"
            # For Mac App Store distribution, we need to embed the provisioning profile
            echo "Embedding provisioning profile..."
            cp embedded.provisionprofile PortManager.app/Contents/embedded.provisionprofile
            
            # Sign the app with the App Store certificate
            codesign --force --deep --sign "$CERT_NAME" --entitlements PortManager.entitlements PortManager.app
        else
            echo "No suitable certificate found, using ad-hoc signing"
            echo "Available certificates:"
            security find-identity -v -p codesigning build.keychain
            codesign --force --deep --sign - --entitlements PortManager.entitlements PortManager.app
        fi
        
        # Verify the signature
        codesign --verify --verbose PortManager.app
        
        # Create App Store package
        echo "Creating App Store package..."
        # Get the exact installer certificate name from the keychain
        echo "Searching for installer certificates..."
        echo "All available certificates:"
        security find-identity -v -p codesigning build.keychain
        echo ""
        echo "Looking for installer-specific certificates..."
        security find-identity -v -p codesigning build.keychain | grep -E "(Mac Installer Distribution|Mac Installer Submission|3rd Party Mac Developer Installer)" || echo "No installer certificates found with expected names"
        
        # Look specifically for installer certificates (only App Store compatible ones)
        # First try to find any certificate with "Installer" in the name (all certificates, not just codesigning)
        INSTALLER_CERT_NAME=$(security find-identity -v build.keychain | grep -i installer | head -1 | sed 's/.*"\(.*\)".*/\1/')
        
        # If not found, try the specific patterns in all certificates
        if [ -z "$INSTALLER_CERT_NAME" ]; then
            INSTALLER_CERT_NAME=$(security find-identity -v build.keychain | grep -E "(Mac Installer Distribution|Mac Installer Submission|3rd Party Mac Developer Installer)" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        fi
        
        # If still not found, try codesigning certificates only
        if [ -z "$INSTALLER_CERT_NAME" ]; then
            INSTALLER_CERT_NAME=$(security find-identity -v -p codesigning build.keychain | grep -i installer | head -1 | sed 's/.*"\(.*\)".*/\1/')
        fi
        
        if [ -n "$INSTALLER_CERT_NAME" ]; then
            echo "Found installer certificate: $INSTALLER_CERT_NAME"
            echo "Using certificate for package signing: $INSTALLER_CERT_NAME"
            echo "Running productbuild command..."
            productbuild --component PortManager.app /Applications --sign "$INSTALLER_CERT_NAME" PortManager.pkg
            echo "Package created with certificate: $INSTALLER_CERT_NAME"
            
            # Verify the package signature
            echo "Verifying package signature..."
            pkgutil --check-signature PortManager.pkg || echo "Package signature verification failed"
            
            # Show package info
            echo "Package info:"
            pkgutil --pkg-info-plist PortManager.pkg || echo "Could not get package info"
        else
            echo "No installer certificate found, creating unsigned package"
            echo "Note: You need a 'Mac Installer Distribution' or '3rd Party Mac Developer Installer' certificate for signed packages"
            echo "Available certificates:"
            security find-identity -v -p codesigning build.keychain | grep -i installer || echo "No installer certificates found"
            echo "Creating unsigned package (this may cause validation errors)"
            productbuild --component PortManager.app /Applications PortManager.pkg
            echo "Package created WITHOUT certificate (unsigned)"
            
            # Verify the package signature
            echo "Verifying unsigned package..."
            pkgutil --check-signature PortManager.pkg || echo "Package signature verification failed"
        fi
        
        # Set up App Store Connect API
        echo "Setting up App Store Connect API..."
        
        # Debug: Log the App ID (first few characters only for security)
        echo "Debug: APP_IDENTIFIER secret length: $(echo "${{ secrets.APP_IDENTIFIER }}" | wc -c)"
        echo "Debug: APP_IDENTIFIER first 5 chars: $(echo "${{ secrets.APP_IDENTIFIER }}" | cut -c1-5)"
        echo "Debug: APP_IDENTIFIER last 5 chars: $(echo "${{ secrets.APP_IDENTIFIER }}" | rev | cut -c1-5 | rev)"
        
        mkdir -p ~/.appstoreconnect/private_keys
        echo "${{ secrets.APPSTORE_API_KEY_BASE64 }}" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APPSTORE_API_KEY_ID }}.p8
        
        # Upload to App Store Connect using traditional username/password approach
        echo "Uploading to App Store Connect..."
        xcrun altool --upload-app -f PortManager.pkg -t macos \
          -u "${{ secrets.APPLE_ID }}" \
          -p "${{ secrets.APPLE_ID_PASSWORD }}" \
          --output-format xml \
          --verbose
        
        # Clean up
        rm -f certificate_app.p12 certificate_installer.p12
        rm -f AuthKey_${{ secrets.APPSTORE_API_KEY_ID }}.p8
        security delete-keychain build.keychain
        
        # Create distribution files
        echo "Creating distribution files..."
        
        # Create zip for direct distribution (fallback)
        zip -r PortManager-$VERSION.zip PortManager.app
        zip -r PortManager.zip PortManager.app
        
        # Create DMG for direct distribution
        hdiutil create -volname "Port Manager" -srcfolder PortManager.app -ov -format UDZO PortManager-$VERSION.dmg 2>/dev/null || echo "DMG creation failed"
        
        # Remove quarantine attributes
        xattr -d com.apple.quarantine PortManager-$VERSION.zip 2>/dev/null || true
        xattr -d com.apple.quarantine PortManager.zip 2>/dev/null || true
        xattr -d com.apple.quarantine PortManager-$VERSION.dmg 2>/dev/null || true
        
        echo "App bundle created successfully!"
        echo "Version: $VERSION"
        echo "Size: $(du -sh PortManager.app | cut -f1)"
        
    - name: Get version
      id: version
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        else
          echo "VERSION=dev-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
        fi
        
    - name: List files for debugging
      run: |
        echo "Current directory contents:"
        ls -la
        echo "Checking if PortManager.zip exists:"
        ls -la PortManager.zip || echo "PortManager.zip not found"
        
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: |
          PortManager.zip
          PortManager-${{ steps.version.outputs.VERSION }}.dmg
          PortManager.pkg
        body: |
          ## Port Manager ${{ steps.version.outputs.VERSION }}
          
          A lightweight macOS menu bar application for managing open ports.
          
          ### Features
          - 🖥️ Menu bar integration with simple "P" icon
          - 🔍 Port scanning using `lsof`
          - 📊 Services grouped by name with port counts
          - ⚡ One-click process termination
          - 💾 Memory optimized (~2-5MB idle)
          - 🔒 Single instance enforcement
          
          ### Installation
          
          **For App Store (Recommended):**
          1. Download `PortManager.pkg`
          2. Double-click to install
          3. Look for "P" icon in menu bar
          
          **For Direct Installation:**
          1. Download `PortManager.zip`
          2. Extract the `PortManager.app` file
          3. Drag to Applications folder
          4. Right-click → Open (to bypass security warnings)
          5. Look for "P" icon in menu bar
          
          ### Requirements
          - macOS 14.0 or later
          
          ### First Run
          You may need to right-click and "Open" the first time due to macOS security.
          
          ### Building from Source
          ```bash
          git clone https://github.com/${{ github.repository }}
          cd free-ports
          swift run PortManager
          ```
          
          ---
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.event.after }}
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Upload Artifacts
      if: github.event_name == 'workflow_dispatch'
      uses: actions/upload-artifact@v4
      with:
        name: PortManager-${{ steps.version.outputs.VERSION }}
        path: PortManager.zip
